## Professional Summary

When I first started my computer science journey in early 2017, I understood and practiced simple computer tasks. Still, I did not fully comprehend just how sophisticated and inspiring computer science is. I started learning Python, a comfortable and forgiving language to learn. Python exposed me to the fundamental concepts of any language, data types, variables, etc. Then I ran into the for and while loops. In short, loops wrecked my world, not because I didn’t understand what they were or their purpose, but I didn’t understand how or why they worked. That is when I fell down the hypothetical rabbit hole. I am an individual that has a burning desire to understand the world around me. At ten years old, I took the family computer and broke it down to every last screw, and then I attempted to reassemble it. Seeing the computer on the surface wasn’t good enough for me; I needed to understand what was inside that made the computer work. Python, being as mysterious as it was, became my new target. That trend would continue through my professional exploration of computer science. Because of how massive the field is, I know I will continue developing my knowledge and myself.
	I learned that software engineers do not work alone; codebases, especially those in large projects, have many dynamics that need to integrate into synergetic harmony. It requires too much effort for one person to be effective in an environment with strict deadlines and quality control concerns. As such, with the insertion of multiple developers, codebases can get messy. Teams need to have a useful paradigm and business processes to provide results regularly. I perform work based on the AGILE methodology and used version control software Git to organize the code. I had the opportunity to explore multiple roles, including developer, tester, scrum master, and even a product manager. Utilizing Git, I obtained first-hand experience working on remote repositories. I made pull requests, created developmental branches, created new features, pushed code back to the repository, and reviewed the code of other collaborators, all before merging new code into the master branch.
	Not everything task I have performed included technical skills. I learned that clients and investors play a significant role in the developmental process. Software teams need to communicate with their clients to produce user requirements consistently and effectively; in the agile methodology, this process leads to user stories, a tool to develop functionality in software. Developers can create elaborate programs with all of the bells and whistles, but if that program does not meet the client’s needs or is too complicated to use, it is virtually useless. After all, what is the purpose of a business that does not satisfy its clients’ needs? 
	The topic with the most demanding needs of cognitive ability was data structures and algorithms. Nearly every function produced in a programming language fits the algorithm’s definition as a set of instructions for a computer to interpret. The particular algorithms and data structures I studied were of unified importance to software development and laid a foundation to produce even more complicated, useful, and efficient algorithms in the future. To build this foundation, I utilized the C++ language as its low-level architecture was immensely helpful to create a deep understanding of how the computer interprets instructions, including managing the computer’s RAM, which is handled automatically by many higher-level languages. 
The efficiency of an algorithm is measured by how effectively the algorithm can scale with large inputs. There are two factors that a developer needs to consider when developing an algorithm: time complexity and space complexity.  Software engineers use Big “O” notation to demonstrate time and space complexity. For example, O(1) and O(log n), known as constant and logarithmic time, is considered to scale effectively with large datasets. On the other hand of the spectrum, O(n^2) and O(n!) (exponential and factorial) rise drastically with a large dataset and are not considered practical in most cases. Unfortunately, this may lead to a trade-off between time and space. Does this program need to be fast to process large amounts of data? Or does the program need to conserve space in memory? It is up to the developer to produce an algorithm that will best fit the organization’s needs or client. These are just a few of the reasons I find data structures and algorithms one of the most intriguing topics in computer science
The critical marker between a simple script and a fully functioning proper application is the relationship between software programs and databases. Programs run on the computer’s RAM, which is thought of as volatile memory as it deletes itself when the program restarts. For the program to be more useful, it can use persistent memory, meaning the memory will save even after a restart. The way to engineer this design is to link the program to a database. Many databases are available, but the most common ones are structure query language(SQL) or non-structured query language(No-SQL). SQL utilized a table-like architecture, like an Excel spreadsheet, to structure data, while No-SQL uses documents similar to objects in most programming languages. Online forums have heavily debated as to which one is the best. Still, they both have advantages and disadvantages and deserve deep consideration when choosing a database.
I have tried to summarize what I have learned during my time in the computer science program, but even a summary does not elaborate on the details I consider essential. Let it be known that this summary does not effectively document everything I have learned over the years. It will take many more pages and then possibly a publisher to demonstrate the knowledge I have gained. Hopefully, it does justice enough, and I am forever grateful for the exposure and professional development.

## Welcome to GitHub Pages

You can use the [editor on GitHub](https://github.com/Lucci-k/lucci-k.github.io/edit/main/index.md) to maintain and preview the content for your website in Markdown files.

Whenever you commit to this repository, GitHub Pages will run [Jekyll](https://jekyllrb.com/) to rebuild the pages in your site, from the content in your Markdown files.

### Markdown

Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for

```markdown
Syntax highlighted code block

# Header 1
## Header 2
### Header 3

- Bulleted
- List

1. Numbered
2. List

**Bold** and _Italic_ and `Code` text

[Link](url) and ![Image](src)
```

For more details see [GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/).

### Jekyll Themes

Your Pages site will use the layout and styles from the Jekyll theme you have selected in your [repository settings](https://github.com/Lucci-k/lucci-k.github.io/settings). The name of this theme is saved in the Jekyll `_config.yml` configuration file.

### Support or Contact

Having trouble with Pages? Check out our [documentation](https://docs.github.com/categories/github-pages-basics/) or [contact support](https://github.com/contact) and we’ll help you sort it out.
